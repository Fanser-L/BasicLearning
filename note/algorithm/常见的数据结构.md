# 数据结构基础

什么是数据结构就不解释了，并没有太大的意义，说到底数据结构就是为了更加高效的访问和修改数据。（data structure）

## 1、线性结构

线性结构是最简单的数据结构，包括数组，链表，以及衍生的栈，队列，哈希表等

### 数组

有限个相同类型的变量所组成的有序集合，数组中的每个变量被称为元素。数组是最简单，最为常用的数据结构。

特点：

- 下标从0开始，直到数组长度-1
- 在内存中顺序存储，可以很好的在逻辑上实现顺序表，需要内存中的一整块的空间。

**一些基本操作：**

1. 读取元素：通过下标呗
2. 更新元素：更新元素一般就是直接覆盖了
3. 插入元素：插入元素需要注意一下，插入元素如果不是在最后一位，那么从插入的位置往后，所有元素都要往后移动一位
4. 删除元素：删除跟插入相反，如果不是最后一位，所有元素要往前移动一位，所以删除和插入的时间复杂度为O(n)

注意：当数组空间不足时，需要对数组进行扩容，其实就是另外再建一个数组，然后把原来的数组的值赋给新的数组。



### 链表

链表分为：单向链表，双向链表，甚至还有环形链表

主要区别在于元素前后的指针，单向链表只有指向下一个元素的指针，而双向链表存在指向上一个元素的指针。

在读取元素上，链表只能通过每个元素的指针一个一个的往下查找，这点是不如数组的。

更新元素上与数组一致，直接覆盖值即可。

插入元素上就比数组简单的多了，只需要修改指针的指向即可，比如说A->C  我们插入一个B在A和C之间,那么只需要让A的指针指向B，然后让B指向C即可，删除则直接让A指向下下个元素即可。

可见：数组在查找上占优势，而链表在插入和删除元素上更占优势。



### 栈

栈是只允许在一端进行插入或删除操作的线性表（**FILO**） 先进后出

入栈（push）只允许元素从一端进栈，新元素会成为新的栈顶 

出栈（pop）就是把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素前的一个元素会成为新的栈顶

递归的逻辑可以通过栈来实现

### 队列

如果说栈是只允许一端进出的线性表，那么队列就更像是一个管道（**FIFO**）先进先出

循环队列：让队尾指针指向队头，然后就可以实现循环队列了。这样怎么判断队满呢？ 当头尾相接的时候就说明队满了（队尾下标+1%数组长度=队头下标）

应用：

双端队列，优先队列等等

双端队列结合了栈和队列的优点，对于双端队列来说，一端可以入队或者出队，另一端也可以入队或者出队。

优先队列的实现是基于二叉堆来实现的。



### 散列表（hash table）

通过类似字典的方式来进行查找的操作，这种数据结构中提供了**Key：Value**的映射关系

如何进行查找呢？ 需要一个中转站——hash函数

**index = HashCode（key）%Array.length** 获取对应的数组下标，但是这样子获取的值会存在冲突，如何来解决呢？

主要有两种解决方案：开放寻址法和链表法

Java中ThreadLocal使用的就是开放寻址法，HashMap则是使用的链表法

开放寻址法：没位置了就往旁边找，找到就占了，先到先得

链表法：没位置了没关系，当前位置使用指针指向到下一个节点中再存入即可

**扩容**

影响HashMap的扩容的因素有两个：

- capacity ， 即hashmap的当前长度
- LoadFactor ，即hashmap的负载因子，默认值为0.75f
- 衡量hashmap需要扩容的条件如下：**HashMap.Size >= Capacity * LoadFactor**

数组的扩容是直接两倍的长度，而hash的扩容却不是这样的,首先创建一个新数组，长度是原来的两倍，然后需要重新hash

https://wiki.jikexueyuan.com/project/java-collection/hashmap.html

## 2、树

树是相对而言比较复杂的数据结构，比较有代表性的就是二叉树了





## 3、图

更加复杂的数据结构，存在多对多的关系

## 4、其他数据结构

跳表，哈希链表，位图等等，都是有上面那些基本的数据结构衍生而来的特殊的数据结构