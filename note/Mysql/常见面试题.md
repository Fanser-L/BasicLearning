## 请你说说MySQL的事务隔离级别

得分点 未提交读、已提交读、可重复读、可串行化 标准回答 SQL 标准定义了四种隔离级别,这四种隔离级别分别是： 

- 读未提交（READ UNCOMMITTED）；
- 读提交 （READ COMMITTED）； 
- 可重复读 （REPEATABLE READ）； 
- 串行化 （SERIALIZABLE）。

事务隔离是为了解决脏读、不可重复读、幻读问题,下表展示了 4 种隔离级别对这三个问题的解决程度： 

| 隔离级别         | 脏读   | 不可重复读 | 幻读   |
| :--------------- | :----- | :--------- | :----- |
| READ UNCOMMITTED | 可能   | 可能       | 可能   |
| READ COMMITTED   | 不可能 | 可能       | 可能   |
| REPEATABLE READ  | 不可能 | 不可能     | 可能   |
| SERIALIZABLE     | 不可能 | 不可能     | 不可能 |

上述4种隔离级别MySQL都支持,并且InnoDB存储引擎默认的支持隔离级别是REPEATABLE READ,但是与标准SQL不同的是,InnoDB存储引擎在REPEATABLE READ事务隔离级别下,使用Next-Key Lock的锁算法,因此避免了幻读的产生。所以,InnoDB存储引擎在默认的事务隔离级别下已经能完全保证事务的隔离性要求,即达到SQL标准的SERIALIZABLE隔离级别；

加分回答 READ UNCOMMITTED： 它是性能最好、也最野蛮的方式,因为它压根儿就不加锁,所以根本谈不上什么隔离效果,可以理解为没有隔离。 

SERIALIZABLE： 读的时候加共享锁,其他事务可以并发读,但是不能写。写的时候加排它锁,其他事务不能并发写也不能并发读。 

REPEATABLE READ & READ COMMITTED： 为了解决不可重复读,MySQL 采用了 MVVC (多版本并发控制) 的方式。

我们在数据库表中看到的一行记录可能实际上有多个版本,每个版本的记录除了有数据本身外,还要有一个表示版本的字段,记为 row trx_id,而这个字段就是使其产生的事务的 id,事务 ID 记为 transaction id,它在事务开始的时候向事务系统申请,按时间先后顺序递增。

事务隔离级别是为了解决脏读、不可重复读、幻读 

脏读：一个事务读取了另一个事务未提交的数据 

不可重复读：事务A两次读取的数据不一致，读第二次之前可能有其他事务修改了这个数据并提交了 

幻读：事务A两次读取数据库，两次查询结果的条数不同，称为幻读。行数变了即为幻读，数据变了即为不可重复度 

事务隔离级别如下： 读未提交：以上三个问题都解决不了 读已提交：只能解决脏读 可重复读：mysql的默认隔离级别，能解决脏读和不可重复读，包含了间隙锁，可以防止幻读 串行化：都可以解决。（为每个读取操作加一个共享锁）